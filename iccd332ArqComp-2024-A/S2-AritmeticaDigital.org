
#+options: ':nil *:t -:t ::t <:t H:2 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: S2 Aritmética Digital
#+date: 2024-04-28
#+author: Lenin G. Falconí
#+email: lenin.falconi@epn.edu.ec
#+language: es
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 27.1 (Org mode 9.3)

# to enable beamer mode M-x org-beamer-mode
#+options: H:2
#+latex_class: beamer
#+columns: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+beamer_theme: Madrid
#+beamer_color_theme:
#+beamer_font_theme:
#+beamer_inner_theme:
#+beamer_outer_theme:
#+beamer_header:


* Aritmética Digital
** Unidad Aritmética Lógica (ALU)
*** Texto                                                             :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.4
    :END:
- Está encargada de realizar las operaciones **lógicas** y
  **aritméticas** sobre los datos
- Está conformada de dispositivos electrónicos que permiten el
  almacenamiento de dígitos binarios y ejecutar operaciones Booleanas
- La ALU se interconecta por señales de control, utiliza 2 registros y emite flags
*** Imagen                                                     :BMCOL:Imagen:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :END:

[[./images/ALU.png]]

** Representación de Números Enteros
- No se dispone de signos +/- para representar los números
- No se dispone de un punto decimal
- Un número entero queda representado por un conjunto de 0s y 1s
- Por tanto, un dígito ha de ser usado para representar el signo
- Una secuencia de $n$ dígitos binarios se interpreta como un entero $A$
  **sin signo**

$$A = \sum_{i=0}^{n-1}2^ia_i$$

** Representación Signo - Magnitud
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

- El bit más significativo de la izquierda (LMSB) se considera el signo
- 0 $\rightarrow$ positivo
- 1 $\rightarrow$ negativo
- Si la palabra tiene $n$ dígitos:
  - El $n$ - simo bit es el signo
  - Los $n-1$ bits son la magnitud

$$A = \begin{cases}
\sum_{i=0}^{n-2}2^ia_i & \text{if $a_{n-1} = 0$} \\
-\sum_{i=0}^{n-2}2^ia_i & \text{if $a_{n-1} = 1$}
\end{cases}$$

- El 0 tiene una representación doble como $0^+$ y $0^-$

$$+18 = 00010010$$
$$-18 = 10010010$$

*** Tarea                                                   :B_definition:Tarea:
    :PROPERTIES:
    :BEAMER_env: definition
    :END:

Escribir una función en python que permita dado un número binario de 8
bits obtener su negativo usando el criterio de signo magnitud

** Complemento a base disminuída $r-1$
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

Dado un número $A$ en base $r$ de $n$ dígitos, el complemento a $r-1$
de $A$ es:

$$(r^n-1)-A$$

- Caso Decimal $r=10$ y $r-1=9$. Para un número de $n$ digítios se
  tiene: $(10^n-1)-A$. Donde $(10^n-1)=999 \dots 9 \rightarrow$ n 9s

  Ejemplo: El compleneto a nueve de 546700 es $999999-546700=453299$

- Caso Binario $r=2$ y $r-1=1$, entonces $1111 \dots11 - A$. El
  resultado es la inversión del número

  Ejemplo: Sea $A = 1011000$, el complemento a 1 es
  $1111111-1011000=0100111$


** Representación en Complemento a $r$

El complemento a $r$ de un número $A_r$ de $n$ dígitos es el
complemento a $r^n-A$ i.e.

$r^n-A=(r^n-1)-A+1$

- Caso Binario: Consiste en obtener el complemento a 1 o inversión del
  número binario y sumar 1

** Sistema de Complemento a 2
   :PROPERTIES:
   :BEAMER_opt: allowframebreaks
   :END:

- Utiliza el bit más significativo como signo
- Dispone de una sola representación para el 0
- Si se define un número de $n$ bits como la secuencia
  $A=a_{n-1}a_{n-2} \dots a_2a_1a_0$, entonces el bit del signo es el
  dígito $a_{n-1}$ y el número $A$ en complemento a 2 se representa
  por:

$$A=-2^{n-1}a_{n-1}+\sum_{i=0}^{n-2}2^ia_i$$

- El rango: $-2^{n-1}$ hasta $2^{n-1}-1$
- Se obtiene de invertir cada bit the la cadena $A$ y luego sumar 1
- **Extensión de la longitud en bits:** Si el numéro $A$ de $n$
  dígitos se ha de representar en $m$ dígitos, donde $m \ge n$
  entonces, se añade las posiciones faltantes a la izquierda y se
  rellenan con el valor del bit del signo original.
- **Overflow:** se produce cuando al sumar dos números $A$ y $B$ en
  complemento a 2, el resultado tiene signo opuesto.
- **Resta:** dados $A$ y $B$ y se desea obtener $A-B$, entonces

$$A-B = A+(-B)$$

** Conversión de binario a decimal en complemento a 2
Consiste en aplicar la ecuación de un número en complemento a 2:

#+ATTR_LATEX: :mode inline-math
#+ATTR_LATEX: :environment tabular :font \scriptsize

+----------+----------+----------+----------+----------+----------+----------+----------+
|$-2^7$    |$-2^6$    |  $2^5$   |  $2^4$   |  $2^3$   |  $2^2$   | $2^1$    | $2^0$    |
+----------+----------+----------+----------+----------+----------+----------+----------+
| 1        |0         |0         |0         |0         |0         |1         |1         |
+----------+----------+----------+----------+----------+----------+----------+----------+
|-128      |0         |0         |0         |0         |0         |+2        | +1       |
+----------+----------+----------+----------+----------+----------+----------+----------+

$$A=-2^{n-1}a_{n-1}+\sum_{i=0}^{n-2}2^ia_i$$

$A=1000\,0011_2=-128+2+1=-125$

** Representaciones con Signo

- Los números negativos se representan por su **complemento**
- En un sistema de numeración binaria (e.g. ALU) se usa el
  **complemento a 2**
- Se asume que el $0$ en la MSB es **positivo**

Por ejemplo $-9$ en una máquina de 8 bits puede representarse como:


+---------------+----------+
|Sistema        |   -9     |
+---------------+----------+
|Magnitud Signo | 10001001 |
+---------------+----------+
|Complemento 1  | 11110110 |
+---------------+----------+
|Complemento 2  | 11110111 |
+---------------+----------+

